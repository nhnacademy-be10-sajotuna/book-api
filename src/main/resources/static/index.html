<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>책 목록</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
    .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1, h2 { color: #333; }
    button {
      padding: 10px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-right: 10px;
    }
    button:hover { background-color: #0056b3; }
    #bookList, #categoryList {
      margin-top: 20px;
      border-collapse: collapse;
      width: 100%;
    }
    #bookList th, #bookList td,
    #categoryList th, #categoryList td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    #bookList th, #categoryList th {
      background-color: #f2f2f2;
    }
    .category-item {
      padding: 5px 0;
      border-bottom: 1px dashed #eee;
    }
    .category-item:last-child {
      border-bottom: none;
    }
    .sub-categories {
      margin-left: 20px;
      font-size: 0.9em;
      color: #555;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>책 정보 관리</h1>
  <p>이 페이지는 Spring Boot 백엔드에서 제공하는 API를 사용하여 데이터를 표시합니다.</p>

  <h2>책 목록</h2>
  <button onclick="loadBooks()">책 목록 가져오기</button>
  <table id="bookList">
    <thead>
    <tr>
      <th>ISBN</th>
      <th>제목</th>
      <th>저자</th>
      <th>가격</th>
      <th>할인율</th>
      <th>카테고리</th>
    </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <hr>

  <h2>카테고리 목록</h2>
  <button onclick="loadCategories()">카테고리 목록 가져오기</button>
  <div id="categoryList">
  </div>
</div>

<script>
  // 책 목록 가져오기
  async function loadBooks() {
    try {
      const response = await fetch('http://localhost:8080/api/books');
      const books = await response.json();
      const bookListBody = document.querySelector('#bookList tbody');
      bookListBody.innerHTML = ''; // 기존 목록 초기화

      if (books.length === 0) {
        bookListBody.innerHTML = '<tr><td colspan="6">등록된 책이 없습니다.</td></tr>';
        return;
      }

      books.forEach(book => {
        const row = bookListBody.insertRow();
        row.insertCell().textContent = book.isbn;
        row.insertCell().textContent = book.title;
        row.insertCell().textContent = book.author;
        row.insertCell().textContent = book.sellingPrice.toLocaleString('ko-KR') + '원';
        row.insertCell().textContent = book.discountRate.toFixed(2) + '%';
        const categoryNames = book.categories.map(cat => cat.name).join(', ');
        row.insertCell().textContent = categoryNames;
      });
    } catch (error) {
      console.error('책 목록을 가져오는 중 오류 발생:', error);
      alert('책 목록을 가져오지 못했습니다. 서버가 실행 중인지 확인하세요.');
    }
  }

  // 카테고리 목록 가져오기
  async function loadCategories() {
    try {
      const response = await fetch('http://localhost:8080/api/books/categories');
      const categories = await response.json();
      const categoryListDiv = document.getElementById('categoryList');
      categoryListDiv.innerHTML = ''; // 기존 목록 초기화

      if (categories.length === 0) {
        categoryListDiv.innerHTML = '<p>등록된 카테고리가 없습니다.</p>';
        return;
      }

      // 카테고리를 계층적으로 표시 (필요에 따라 더 복잡한 트리 구조로 변환 가능)
      function renderCategory(category, level = 0) {
        let html = `<div class="category-item" style="padding-left: ${level * 15}px;">`;
        html += `<strong>ID: ${category.id}</strong> | 이름: ${category.name}`;
        if (category.parentCategoryName) {
          html += ` (상위: ${category.parentCategoryName})`;
        }
        html += `</div>`;

        if (category.subCategories && category.subCategories.length > 0) {
          html += `<div class="sub-categories">`;
          category.subCategories.forEach(sub => {
            html += renderCategory(sub, level + 1);
          });
          html += `</div>`;
        }
        return html;
      }

      // 최상위 카테고리 (parentCategoryName이 null인 카테고리)만 찾아서 표시
      // 이 예시에서는 모든 카테고리를 리스트로 보여주기 때문에 `parentCategoryName`이 `null`인 카테고리부터 시작해서
      // `subCategories`를 통해 계층을 표현합니다.
      // 만약 API에서 이미 트리 형태의 DTO를 반환한다면, `parentCategoryName`으로 필터링하는 로직이 더 필요할 수 있습니다.
      categories.forEach(cat => {
        // 여기서는 API가 모든 카테고리를 평탄하게 반환하므로,
        // 간단히 각 카테고리의 정보와 그 안에 포함된 하위 카테고리(DTO에서 이미 처리됨)를 표시합니다.
        // 실제 프론트엔드에서는 최상위 부모만 필터링하여 트리를 구축하는 로직을 사용합니다.
        categoryListDiv.innerHTML += renderCategory(cat);
      });


    } catch (error) {
      console.error('카테고리 목록을 가져오는 중 오류 발생:', error);
      alert('카테고리 목록을 가져오지 못했습니다. 서버가 실행 중인지 확인하세요.');
    }
  }
</script>
</body>
</html>